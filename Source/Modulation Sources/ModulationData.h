/*
  ==============================================================================

    ModulationData.h
 
    Author:  Michael Kauffmann

    A struct that manage modulation data, generated by modulation sources(LFO, envf, envelope), and the target modulation data (modulationSource, value, target) updated from controller (pluginprocessor). 
    The data can be accessed from multiple classes that have a reference to the same instance of struct modulationData. 
    Data is used to modulate target DSP parameters.
    The struct also access the data and modulate modulation sources rate(LFO) and sensitivity (envelope follower). 
    This responisibility should have been put in the LFO and envelope follower class. I might refactor this later. 

    // TO DO: Move responsibility "setting/update" the ModulationTargetData tuple to modulationData.h. From pluginProcessor.h, Simply pass index, source, value and target as parameter.



  ==============================================================================
*/


#pragma once

#include <JuceHeader.h>
#include "MFXLFO2.h"
#include "MFXEnvelopFollower.h"
#include "MFXUsedParameters.h"
#include "MFXADSR.h"




struct ModulationData
{
    ModulationData()
    {
        initializeModulationSources();
        
        for (size_t i = 0; i < notes.size(); i++)
        {
            notes[i] = 1; // default all notes off
        }
       
    }
    
    ~ModulationData(){}
    
    
    void prepare(const juce::dsp::ProcessSpec& spec)
    {
        
        for (int i = 0; i < 5; i++)
        {
            mModulatorOutput[i].setSize(1, spec.maximumBlockSize);
            mModulatorOutput[i].clear(0, spec.maximumBlockSize);
        }
        
        mModulationTargetData.resize(10);  
        
        mLfoModulator1->prepare(spec);
        mLfoModulator2->prepare(spec);
        
        mEnvelopeFollower->prepare(spec);
        
        mADSR->prepare(spec);
        mADSR2->prepare(spec);
    }
    
    /** @param bufferWriterPointer is data to feed envelope follower*/  // I don't use playhead, refactor out.
    void processModulationOutput(juce::AudioPlayHead* playHead, float* bufferWriterPointer, int numSamples, double sampleRate, juce::MidiBuffer& midiMessages)
    {
        
        float* modulatorsWriterPointer[5] = { mModulatorOutput[LFO1].getWritePointer (0),
                                              mModulatorOutput[LFO2].getWritePointer (0),
                                              mModulatorOutput[EnvF].getWritePointer(0),
                                              mModulatorOutput[adsr].getWritePointer(0),
                                              mModulatorOutput[adsr2].getWritePointer(0) };
        
        // Used for reading midi data (note on/off)
        juce::MidiBuffer::Iterator iterator(midiMessages);
        juce::MidiMessage currentMessage;

        
        for(int i = 0; i < numSamples; i++)
        {
            
            auto modSumRateLFO1 = 0.0f;
            auto modSumRateLFO2 = 0.0f;
            auto modSumRateEnv = 0.0f;
        
            modulatorsWriterPointer[LFO1][i] = mLfoModulator1->process();
            modulatorsWriterPointer[LFO2][i] = mLfoModulator2->process();
            modulatorsWriterPointer[EnvF][i] = mEnvelopeFollower->processSample(0, bufferWriterPointer[i]);

            iterator.getNextEvent(currentMessage, i);


            if (currentMessage.isNoteOn()) {

                notes[currentMessage.getNoteNumber()] = 0; // 0 means note is on

                mADSR->updateADSR();
                
                // we start attack phase of envelope
                mADSR->noteOn();
                
                mADSR2->updateADSR();
                mADSR2->noteOn();

                if(isLFO1Trigger)
                   mLfoModulator1->reset(); // retrigger LFO
                
                if (isLFO2Trigger)
                    mLfoModulator2->reset(); // retrigger LFO
                

                mIsMidi = true;
            }
                

            else if (currentMessage.isNoteOff())
            {
                notes[currentMessage.getNoteNumber()] = 1; // note is off
                int isAllNoteOff = 0;

                for (size_t i = 0; i < notes.size(); i++)
                {
                    isAllNoteOff += notes[i]; // sum current note on/off values
                }

                // If isAllNoteOff is equal 127 all notes are off and we can trigger envelope release state. The idea is to have a kind of poly triggered ADSR.
                //  If one or more keys are down then note off must note be triggered.
                // Instead envelope will start from begining (attack phase, noteOn() above). 
                if (isAllNoteOff == 127)
                {
                    mADSR->noteOff();
                    mADSR2->noteOff();
                    mIsMidi = false;   
                }
            }
            
            // Reading/storing values from active envelope    
            modulatorsWriterPointer[adsr][i] = mADSR->isActive() ? mADSR->getNextSample() : 0.0f;
            modulatorsWriterPointer[adsr2][i] = mADSR2->isActive() ? mADSR2->getNextSample() : 0.0f;



            // Here we modulate LFO's rate and envelope followers sensitivity
                    
            for (auto set : mModulationTargetData)
            {
                if (std::get<1>(set) == LFO1_Rate)
                {
                    
                    modSumRateLFO1 +=  modulatorsWriterPointer[std::get<0>(set)][i] * std::get<2>(set);
                }
                
                else if (std::get<1>(set) == Wildcard)
                {
                    modSumRateLFO2 +=  modulatorsWriterPointer[std::get<0>(set)][i] * std::get<2>(set);   
                }
                
                else if (std::get<1>(set) == EnvelopeSensitivity)
                {
                    modSumRateEnv +=  modulatorsWriterPointer[std::get<0>(set)][i] * std::get<2>(set);   
                }
            }
            
            if (!(bool)mIsSyncLFO1)
            {
                mLfoModulator1->updateParams(mCurrentLFO1ParamRate, 1.0f, modSumRateLFO1);
            }
            else
            {
                mLfoModulator1->updateParamsSync(mCurrentParamBpm, mCurrentLFO1ParamNote, 1.0f, modSumRateLFO1);
            }

            
            if (!(bool)mIsSyncLFO2)
            {
                mLfoModulator2->updateParams(mCurrentLFO2ParamRate, 1.0f, modSumRateLFO2);
            }
            else
            {
                mLfoModulator2->updateParamsSync(mCurrentParamBpm, mCurrentLFO2ParamNote, 1.0f, modSumRateLFO2);
            }
            
            

            mEnvelopeFollower->setRatio(mCurrentEnvParamSensitivity, modSumRateEnv);

                
            
        }// end main loop
       
    }
    
   
    
    void initializeModulationSources()
    {   
        mLfoModulator1 = std::make_unique<MFXLFO2>();
        mLfoModulator2 = std::make_unique<MFXLFO2>();
        mEnvelopeFollower = std::make_unique<MFXEnvelopeFollower<float>>();
        mADSR = std::make_unique<MFXADSR>();
        mADSR2 = std::make_unique<MFXADSR>();
    }
    
    
    
    
    //---------------------------------------------------------------------------------------------------------------------------------------------------------
    
    std::unique_ptr<MFXLFO2> mLfoModulator1;  // Remember changes made to original reset() in JUCE OSC class
    std::unique_ptr<MFXLFO2> mLfoModulator2;
    AudioBuffer<float> mModulatorOutput[5];
    std::unique_ptr<MFXEnvelopeFollower<float>> mEnvelopeFollower;
    std::unique_ptr<MFXADSR> mADSR;
    std::unique_ptr<MFXADSR> mADSR2;
    //indexed by Notenumber, value noteOff bool 0/1. value 1 is note off and 0 is note on.
    std::array<int,127> notes;
    
    // params are modulation source(int), index of target in stringArray UI Target param (int), amount to apply/scale modulation output sample with(float).
    std::vector<std::tuple<int, int, float>> mModulationTargetData;
    
    
    // Current modulation source parameters ----------------------------------------------------------------------------------------------------------------------

    float mCurrentEnvParamSensitivity {0.0f};
    
    
    float mCurrentLFO1ParamRate {0.0f};
    float mCurrentLFO1ParamNote {0.0f};
    
    double mCurrentParamBpm {0.0f};
    bool mIsSyncLFO1 {false};
    bool mIsSyncLFO2 {false};    
    
    float mCurrentLFO2ParamRate {0.0f};
    float mCurrentLFO2ParamNote {0.0f};
    bool isLFO1Trigger{false};
    bool isLFO2Trigger{ false };

    // Is receiving midi state
    bool mIsMidi{ false };

    
    
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ModulationData);
};

